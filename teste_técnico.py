# -*- coding: utf-8 -*-
"""Teste técnico

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fwatKIvW3ZZwOImV1FQfhJCXXylhHwbE
"""

import numpy as np

# from google.colab import drive
# drive.mount('/content/drive/')

import pandas as pd
data = pd.read_csv('/content/drive/MyDrive/Indicium - Lighthouse/desafio_indicium_imdb.csv')
print(data.head())

# Verificar os tipos de dados
print(data.dtypes)

# Mostrar valores únicos na coluna Released_Year
unique_values = data['Released_Year'].unique()
print("Valores únicos na coluna 'Released_Year':")
print(unique_values)

# Mostrar contagem de cada valor na coluna Released_Year
value_counts = data['Released_Year'].value_counts()
print("\nContagem de cada valor na coluna 'Released_Year':")
print(value_counts)

# Filtrar apenas os valores que são anos válidos (valores numéricos)
data = data[data['Released_Year'].str.isdigit()]

# Converter o ano de lançamento para inteiro
data['Released_Year'] = data['Released_Year'].astype(int)

# Converter a coluna de duração para um formato numérico (em minutos)
data['Runtime'] = data['Runtime'].str.replace(' min', '').astype(int)

# Converter as colunas de classificação IMDb, Meta_score e Gross para float
data['IMDB_Rating'] = data['IMDB_Rating'].astype(float)
data['Meta_score'] = data['Meta_score'].astype(float)
data['Gross'] = data['Gross'].str.replace(',', '').astype(float)

print(data.dtypes)

# Contar valores ausentes em cada coluna
print(data.isnull().sum())

# Mostrar valores únicos na coluna Certificate
unique_values = data['Certificate'].unique()
print("Valores únicos na coluna 'Certificate':")
print(unique_values)

# Mostrar contagem de cada valor na coluna Certificate
value_counts = data['Certificate'].value_counts()
print("\nContagem de cada valor na coluna 'Certificate':")
print(value_counts)

# Preencher valores ausentes com X para certificate
data['Certificate'].fillna('X', inplace=True)

# Mostrar valores únicos na coluna Certificate
unique_values = data['Certificate'].unique()
print("Valores únicos na coluna 'Certificate':")
print(unique_values)

# Mostrar contagem de cada valor na coluna Certificate
value_counts = data['Certificate'].value_counts()
print("\nContagem de cada valor na coluna 'Certificate':")
print(value_counts)

# Preencher valores ausentes de Meta_scores com 0
data['Meta_score'].fillna(0, inplace=True)

# Preencher valores ausentes de Gross com 0
data['Gross'].fillna(0, inplace=True)

print(data.isnull().sum())

# Remover a coluna 'Unnamed: 0'
data = data.drop(columns=['Unnamed: 0'])

# Exibir informações resumidas para verificar o resultado da limpeza
print(data.info())

descriptive_stats = data.describe()
print("Estatísticas Descritivas:")
print(descriptive_stats)

import matplotlib.pyplot as plt
import seaborn as sns

# Histograma do IMDB_Rating
plt.figure(figsize=(10, 6))
sns.histplot(data['IMDB_Rating'], bins=10, kde=True)
plt.title('Distribuição do IMDB Rating')
plt.xlabel('IMDB Rating')
plt.ylabel('Frequência')
plt.show()
#Esse gráfico significa que a maior frequência dos filmes desse dataset (mais de 250) possuem nota do IMDB entre 7.6 e 7.8.

# Histograma do Meta_score
plt.figure(figsize=(10, 6))
sns.histplot(data['Meta_score'], bins=10, kde=True)
plt.title('Distribuição da Média ponderada de todas as críticas ')
plt.xlabel('Meta Score')
plt.ylabel('Frequência')
plt.show()

# Estatísticas descritivas da coluna Gross
gross_stats = data['Gross'].describe()
print("Estatísticas Descritivas da Receita Bruta:")
print(gross_stats)

# Remover casas decimais e converter a coluna Gross para inteiros
data['Gross'] = data['Gross'].astype(int)

# Verificar as primeiras linhas para confirmar a conversão
print(data['Gross'].head(10))

# Primeiras 10 linhas da coluna Gross
print("\nPrimeiras 10 Linhas da Coluna Gross:")
print(data['Gross'].head(10))

# Últimas 10 linhas da coluna Gross
print("\nÚltimas 10 Linhas da Coluna Gross:")
print(data['Gross'].tail(10))


# Histograma do Gross
plt.figure(figsize=(10, 6))
sns.histplot(data['Gross'], bins=10, kde=True)
plt.title('Distribuição do Faturamento (em milhões de dólares)')
plt.xlabel('Faturamento')
plt.ylabel('Frequência')
plt.show()

high_grossing_movies = data[data['Gross'] > 800000000]

# Exibir os filmes que atendem ao critério
print("Filmes com Receita Bruta Acima de 8 Milhões de Dólares:")
print(high_grossing_movies[['Series_Title', 'Gross']])

# Boxplots comparativos
plt.figure(figsize=(15, 8))

# IMDB Rating
plt.subplot(1, 3, 1)
sns.boxplot(y=data['IMDB_Rating'])
plt.title('Boxplot do IMDB Rating')

# Meta Score
plt.subplot(1, 3, 2)
sns.boxplot(y=df['Meta_score'])
plt.title('Boxplot do Meta Score')

# Gross
plt.subplot(1, 3, 3)
sns.boxplot(y=df['Gross'])
plt.title('Boxplot da Receita Bruta')

plt.tight_layout()
plt.show()

# Contagem de cada tipo de certificado
certificate_counts = data['Certificate'].value_counts()
print("Contagem de cada tipo de certificado:")
print(certificate_counts)

certificate_counts = data['Certificate'].value_counts()

# Converter a contagem para um DataFrame
certificate_table = certificate_counts.reset_index()
certificate_table.columns = ['Certificate', 'Count']

# Exibir a tabela formatada
print("Contagem de cada tipo de certificado:")
print(certificate_table.to_string(index=False))

# Gráfico de barras para visualizar a distribuição dos certificados
plt.figure(figsize=(10, 6))
sns.countplot(x='Certificate', data=data, order=certificate_counts.index)
plt.title('Distribuição dos Certificados')
plt.xlabel('Certificado')
plt.ylabel('Contagem')
plt.show()

# Criar uma série combinando as colunas Star1, Star2, Star3 e Star4
stars_series = pd.concat([data['Star1'], data['Star2'], data['Star3'], data['Star4']])

# Contar a frequência de cada estrela
stars_counts = stars_series.value_counts()

# Exibir as estrelas que mais se repetem
print("Estrelas que mais se repetem nas colunas Star1, Star2, Star3 e Star4:")
print(stars_counts.head(10))  # Exibir as 10 estrelas mais frequentes, ajuste conforme necessário

# Calcular top 3 atores mais frequentes
top_actors = pd.concat([data['Star1'], data['Star2'], data['Star3'], data['Star4']]).value_counts().head(3).index.tolist()

# Filtrar filmes dos top 3 atores
filtered_df = data[data[['Star1', 'Star2', 'Star3', 'Star4']].isin(top_actors).any(axis=1)]

# Calcular o Gross médio por ator
average_gross = filtered_df.groupby(['Star1', 'Star2', 'Star3', 'Star4'])['Gross'].mean().reset_index()

# Ordenar por Gross médio decrescente
average_gross = average_gross.sort_values(by='Gross', ascending=False)

# Exibir os resultados
print("Top 3 Atores com o Gross Médio dos Filmes em que Participam:")
print(average_gross.head(3))

# Filtrar filmes com Gross acima de 7 milhões
high_gross_films = data[data['Gross'] > 700000000]

# Identificar atores envolvidos nos filmes com Gross acima de 7 milhões
actors_involved = pd.concat([high_gross_films['Star1'], high_gross_films['Star2'],
                             high_gross_films['Star3'], high_gross_films['Star4']]).unique()

# Exibir os atores envolvidos
print("Atores dos Filmes com Gross Acima de 7 Milhões de Dólares:")
print(actors_involved)

# Listas de atores fornecidas
list1 = ['Robert De Niro', 'Al Pacino', 'Tom Hanks', 'Brad Pitt', 'Clint Eastwood',
         'Matt Damon', 'Christian Bale', 'Leonardo DiCaprio', 'James Stewart', 'Michael Caine']

list2 = ['Joe Russo', 'Daisy Ridley', 'Sam Worthington', 'Robert Downey Jr.',
         'John Boyega', 'Zoe Saldana', 'Chris Evans', 'Oscar Isaac',
         'Sigourney Weaver', 'Mark Ruffalo', 'Domhnall Gleeson', 'Michelle Rodriguez']

# Converter listas para conjuntos (sets) para facilitar a comparação
set1 = set(list1)
set2 = set(list2)

# Encontrar a interseção (atores que aparecem em ambos os conjuntos)
intersection = set1.intersection(set2)

# Exibir resultados
if intersection:
    print("Atores que aparecem em ambos os conjuntos:")
    print(intersection)
else:
    print("Não há atores que aparecem em ambos os conjuntos.")

# Filtrar os atores de interesse
actors_of_interest = ['Joe Russo', 'Daisy Ridley', 'Sam Worthington', 'Robert Downey Jr.',
                      'John Boyega', 'Zoe Saldana', 'Chris Evans', 'Oscar Isaac',
                      'Sigourney Weaver', 'Mark Ruffalo', 'Domhnall Gleeson', 'Michelle Rodriguez']

# Inicializar um dicionário para armazenar contagem de filmes por ator
actor_counts = {}

# Iterar sobre cada ator e contar quantos filmes eles estão
for actor in actors_of_interest:
    # Contar quantas vezes o ator aparece em qualquer uma das colunas Star
    count = ((data['Star1'] == actor) | (data['Star2'] == actor) |
             (data['Star3'] == actor) | (data['Star4'] == actor)).sum()
    actor_counts[actor] = count

# Exibir os resultados
print("Número de Filmes em que Cada Ator Está Envovido:")
for actor, count in actor_counts.items():
    print(f"{actor}: {count}")

# Filtrar filmes com Gross acima de 7 milhões
high_gross_films = data[data['Gross'] > 700000000]

# Contar a participação de cada ator nos filmes com Gross acima de 7 milhões
actor_counts = {}
for actor in actors_of_interest:
    count = ((high_gross_films['Star1'] == actor) | (high_gross_films['Star2'] == actor) |
             (high_gross_films['Star3'] == actor) | (high_gross_films['Star4'] == actor)).sum()
    actor_counts[actor] = count

# Exibir os resultados
print("Número de Filmes com Gross Acima de 7 Milhões em que Cada Ator Está Envovido:")
for actor, count in actor_counts.items():
    print(f"{actor}: {count}")

actor_name = 'Robert Downey Jr.'

# Filtrar filmes em que Robert Downey Jr. está presente
movies_with_actor = data[(data['Star1'] == actor_name) | (data['Star2'] == actor_name) |
                       (data['Star3'] == actor_name) | (data['Star4'] == actor_name)]

# Ordenar filmes por Gross em ordem crescente
movies_with_actor_sorted = movies_with_actor.sort_values(by='Gross')

# Exibir os títulos dos filmes e seus respectivos faturamentos em ordem crescente de Gross
# print(f"Filmes com o ator {actor_name} ordenados por Gross:")
# for index, movie in movies_with_actor_sorted.iterrows():
    # print(f"Título: {movie['Series_Title']}\t\t Released Year: {movie['Released_Year']}\t\t Gross: {movie['Gross']}")

movies_table = movies_with_actor_sorted[['Series_Title', 'Released_Year', 'Gross']]

# Exibir os filmes em formato de tabela
print("Filmes com o ator Robert Downey Jr. ordenados por Gross:")
print(movies_table.to_string(index=False))

actor_name = 'Mark Ruffalo'

# Filtrar filmes em que Mark Ruffalo está presente
movies_with_actor = data[(data['Star1'] == actor_name) | (data['Star2'] == actor_name) |
                       (data['Star3'] == actor_name) | (data['Star4'] == actor_name)]

# Ordenar filmes por Gross em ordem crescente
movies_with_actor_sorted = movies_with_actor.sort_values(by='Gross')

# Selecionar colunas de interesse
movies_table = movies_with_actor_sorted[['Series_Title', 'Released_Year', 'Gross']]

# Exibir os filmes em formato de tabela
print(f"Filmes com o ator {actor_name} ordenados por Gross:")
print(movies_table.to_string(index=False))

actor_name = 'Chris Evans'

# Filtrar filmes em que Chris Evans está presente
movies_with_actor = data[(data['Star1'] == actor_name) | (data['Star2'] == actor_name) |
                       (data['Star3'] == actor_name) | (data['Star4'] == actor_name)]

# Ordenar filmes por Gross em ordem crescente
movies_with_actor_sorted = movies_with_actor.sort_values(by='Gross')

# Selecionar colunas de interesse
movies_table = movies_with_actor_sorted[['Series_Title', 'Released_Year', 'Gross']]

# Exibir os filmes em formato de tabela
print(f"Filmes com o ator {actor_name} ordenados por Gross:")
print(movies_table.to_string(index=False))

first_few_overviews = data['Overview'].head()
print("Primeiras linhas da coluna Overview:")
for overview in first_few_overviews:
    print("- ", overview)

# tentantiva simples de predição do gênero
genre_keywords = {
    'Crime': ['crime', 'detective', 'mystery', 'thriller'],
    'Fantasy': ['fantasy', 'epic adventure', 'magic'],
    'Comedy': ['comedy', 'romantic', 'funny']
}
def infer_genre(overview):
    overview = overview.lower()
    for genre, keywords in genre_keywords.items():
        for keyword in keywords:
            if keyword in overview:
                return genre
    return 'Unknown'  # Retornar 'Unknown' se nenhum gênero for identificado

# Aplicar a função de inferência de gênero à coluna Overview
data['Inferred_Genre'] = data['Overview'].apply(infer_genre)

# Exibir o resultado
print(data[['Series_Title', 'Overview', 'Inferred_Genre']])

######

correlation = data['Meta_score'].corr(data['IMDB_Rating'])
print(f'Correlação entre Meta_score e IMDB_Rating: {correlation}')

gross_by_year = data.groupby('Released_Year')['Gross'].sum()
print(gross_by_year)



import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error


# Selecionar variáveis preditoras e alvo
X = data[['Released_Year',  'Runtime',  'Meta_score', 'Gross']]
y = data['IMDB_Rating']

# Dividir dados em treino e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Inicializar e treinar modelo de regressão linear
model = LinearRegression()
model.fit(X_train, y_train)

# Prever usando dados de teste
y_pred = model.predict(X_test)

# Avaliar performance do modelo
mse = mean_squared_error(y_test, y_pred)
print(f'Mean Squared Error (MSE): {mse}')

# Exemplo de uso do modelo para prever nota do IMDb para um novo filme
# new_data = pd.DataFrame({
#     'Released_Year': [2023],
#     'Runtime': [120],
#     'Meta_score': [85],
#     'Gross': [100000000]
# })
new_data = pd.DataFrame({
    # 'Series_Title': ['The Shawshank Redemption'],
 'Released_Year': [1994],
 'Runtime': [142],
#  'Genre': ['Drama'],
#  'Overview': ['Two imprisoned men bond over a number of years, finding solace and eventual redemption through acts of common decency.'],
 'Meta_score': [80.0],
#  'Director': ['Frank Darabont'],
#  'Star1': ['Tim Robbins'],
#  'Star2': ['Morgan Freeman'],
#  'Star3': ['Bob Gunton'],
#  'Star4': ['William Sadler'],
#  'No_of_Votes': [2343110],
 'Gross': [28341469]
})
# Prever a nota do IMDb para o novo filme
predicted_rating = model.predict(new_data)
print(f'Predicted IMDb Rating: {predicted_rating[0]}')

import pickle
with open('linear_regression_model.pkl', 'wb') as file:
    pickle.dump(model, file)

data['Certificate'] = pd.factorize(data['Certificate'])[0]
data['Genre'] = data['Genre'].astype('category').cat.codes

# Plotando a matriz de correlação
plt.figure(figsize=(10, 8))
sns.heatmap(data[['Released_Year', 'Certificate', 'Runtime', 'Genre', 'Meta_score', 'Gross', 'IMDB_Rating']].corr(), annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)
plt.title('Matriz de Correlação entre Variáveis')
plt.show()